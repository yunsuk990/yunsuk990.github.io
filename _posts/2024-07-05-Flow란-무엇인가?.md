---
layout: post
date: 2024-07-05
title: "Flow란 무엇인가?"
tags: [Android, Flow, ]
categories: [Development, Android, ]
---


### 코루틴 Flow


---


코루틴 Flow는 데이터 스트림이며, Reactive Programming을 지원하기 위한 API를 의미합니다. 먼저 Reactive Programming 이 무엇인지 알아보겠습니다.

- Reactive Programming(반응형 프로그래밍)
	- 연속된 데이터의 변화를 관찰
	- 변화된 데이터를 가공해서 지속적으로 전파


#### Reactive Programming (반응형 프로그래밍)


Reactive Programming이란 데이터가 변경될 때 이벤트를 발생시켜서 데이터를 지속적으로 전달하도록 하는 프로그래밍 방식입니다. 


명령형 프로그래밍에서는 데이터의 소비자는 데이터를 요청한 후 받은 결과값을 일회성으로 수신합니다. 이는 데이터가 필요할 때마다 데이터를 요청해야한다는 점에서 매우 비효율적입니다. 


Reactive Programming에서는 데이터를 생산하는 생산자가 있으며, 데이터의 소비자는 생상자에 구독 요청을 합니다. 그러면 생산자는 새로운 데이터가 들어올 때마다 소비자에게 지속적으로 보내줍니다.



### 반응형 프로그래밍


---

- 비동기적인 데이터 스트림을 이용한 프로그래밍 기법
- 데이터 스트림과 변화의 전파에 중점을 두고, 비동기 데이터 흐름을 쉽게 만들고 관리
- 데이터 == 스트림
- 스트림: 시간순으로 발생하는 이벤트의 나열
- 기본 베이스는 Observer Pattern
- 하나의 데이터 스트림을 감시(구독)하는 대상이 있다면, 데이터 스트림의 변화가 발생할 경우 변화 전파가 일어나 감시하는 대상은 이를 감지하여 관련 작업을 처리


### Flow


---


데이터 스트림에는 다음 세 가지 항목을 포함


[object Promise]

- 생산자: 스트림에 추가되는 데이터를 생산. 코루틴을 활용하여 흐름에서 비동기적으로 데이터가 생산될 수 있음
- 중개자(선택): 스트림에 내보내는 각각의 값이나 스트림 자체를 수정 가능
- 소비자: 스트림의 값을 사용

	_**안드로이드에서 일반적으로..생산자 → 저장소
	                                             사용자 인터페이스 → UI**_


[object Promise]



#### <u>Flow 만들기</u>

1. `flow` 빌더 사용:
- 코루틴 내에서 실행
- emit()을 사용하여 데이터 생산


{% raw %}
```kotlin
fun exampleFlow(): Flow<Int> = flow {
		for(i in 1..3){
				delay(100)
				emit(i) //데이터 생산
		}
}

fun main() = runBlocking {
		exampleFlow().collect { value ->
				println(value)
		}
}
```
{% endraw %}


1. `flowOf` 빌더 사용: 여러 값을 바로 Flow로 변환할 때 사용. 고정된 값 변환에 유용


{% raw %}
```kotlin
val numberFlow = flowOf(1,2,3)
runBlocking{
		numberFlow.collect { value ->
					println(value)
		}
}
```
{% endraw %}


1. `asFlow` 확장함수 사용: 컬렉션이나 다른 유형의 순차적 자료형을 Flow로 변환할때 사용


{% raw %}
```kotlin
val numbers = listOf(1, 2, 3)
val numberFlow = numbers.asFlow()
runBlocking {
    numberFlow.collect { value ->
        println(value)
    }
}
```
{% endraw %}


1. `callbackFlow` 빌더: 콜백 기반 API를 흐름으로 변환할 수 있는 흐름 빌더
- 내부적으로 차단 큐와 매우 유사한 채널을 사용
	- 생성된 채널의 기본 용량은 요소 54개
	- `send()`: 전체 채널에 새 요소 추가하는 경우  →  새 요소를 위한 공간이 생길때까지 생산자를 정지
	- `offer()`: 채널에 요소를 추가하지 않고 즉시 false를 반환
- send() 함수로 다른 CoroutineContext에서 값을 내보내기 가능
- trySend() 함수로 코루틴 외부로 값을 내보내기 가능


#### <u>Flow 수정</u>


중개자는 값을 소비하지 않고도 데이터 스트림을 수정 가능

- filter: 연속된 데이터 중 원하는 데이터로만 필터링할 때 사용
- map: 데이터의 형태를 변환해서 스트림을 만들 때 사용


#### <u>Flow 수집</u>

- collect: 값 수신 대기를 시작하는 흐름을 트리거
	- 정지 함수이므로 코루틴내에서 실행
	- 호출하는 코루틴은 흐름이 종료될때까지 정지될 수 있음


### StateFlow


---


> 💡 흐름에서 최적으로 상태 업데이트를 내보내고 여러 소비자에게 값을 내보낼 수 있는 Flow API


Flow + StateHolder: 기본적으로 Flow 역할 수행 및 상태에 관련된 기능 추가

- 현재 상태 보존: Flow와 같이 데이터 스트림이며, 마지막 상태 값을 저장
- 변경이 일어난 데이터만 방출. 이벤트가 발생해도 데이터가 그대로면 방출 안함

→ 주로 안드로이드에서 뷰의 상태를 나타나는데 사용



{% raw %}
```kotlin
class MainViewModel: ViewModel() {
		private val _username = MutableStateFlow("Unknown")
		val username = _username.asStateFlow()
		init {
				viewModelScope.launch {
						_username.update { loadUserName() }
				}
		}
		private suspend fun loadUserName(): String {
				delay(2000)
				return "username"
		}
}
```
{% endraw %}


- MutableStateFlow(초기값): 값 할당
- asStateFlow(): 불변성 부여
- update: 값 갱신


#### <u>StateFlow vs LiveData</u>


둘 다 관찰 가능한 데이터 홀더 클래스

- StateFlow의 경우 초기 상태를 생성자에 전달해야 하지만 LiveData 의 경우 그렇지 않음
- View가 STOPPED 상태가 되면 LiveData.observe() 는 소비자를 자동으로 취소하는 반면,

	StateFlow 경우 자동으로 수집을 중지하지 않음

- LiveData는 수명주기를 인식하여, 활성 상태의 수명 주기 소유자에게만 업데이트를 보냄


#### <u>Cold Stream vs Hot Stream</u>


데이터를 발행하는 방식에 따라 나뉨

- Cold Stream
	- 느리게 데이터를 발행. 굳이 요청을 하지 않으면 발행 시작 안함
	- 데이터를 발행하는 방식을 정의하고, 실제 구독자가 나타나면 데이터를 생산해서 전달
- Hot Stream
	- 빠르게 데이터를 발행. 누가 요청을 하지 않아도 발행 시작
	- 데이터가 발행되는 즉시 이벤트를 방출하고, 자신을 구독하는 곳에 모두 브로드캐스팅


### SharedFlow


---


> 💡 StateFlow와 유사하게 비동기 데이터 스트림을 여러 구독자에게 방송하는데 사용. 다만 차이점 존재

- 다중 구독자 지원: 다중 구독자에게 동일한 이벤트를 동시에 전달 가능
- 커스텀 버퍼링 전략: 다양한 버퍼링 전략을 제공. 방출된 이벤트들이 버퍼에 저장되는 방식을 정의 가능\

	ex) 버퍼가 가득 찼을 때 이전 이벤트를 삭제하거나, 최신 이벤트만 유지

- replay속성: 최근에 방출된 일정 수의 이벤트를 새로운 구독자에게 제공
